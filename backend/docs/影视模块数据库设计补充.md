# 影视模块数据库设计补充说明

## 📋 文档说明

本文档补充说明影视模块的数据库设计，指出需要在现有表结构基础上添加的字段。

**版本**: v1.0  
**创建日期**: 2025-12-19

---

## 一、需要添加的字段

### 1.1 movie 表

**需要添加的字段**：

```sql
ALTER TABLE `movie` 
ADD COLUMN `tmdb_id` BIGINT DEFAULT NULL COMMENT 'TMDB ID（用于关联TMDB数据）' AFTER `id`,
ADD INDEX `idx_tmdb_id` (`tmdb_id`);
```

**说明**：
- `tmdb_id` 用于关联TMDB数据，支持通过TMDB API自动填充影视信息
- 该字段可空，支持手动创建的影视（不关联TMDB）
- 添加索引以支持通过 `tmdb_id` 快速查询

**完整表结构**（补充后）：

```sql
CREATE TABLE IF NOT EXISTS `movie` (
    `id` BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '影视ID',
    `tmdb_id` BIGINT DEFAULT NULL COMMENT 'TMDB ID（用于关联TMDB数据）',
    `title` VARCHAR(255) NOT NULL COMMENT '标题',
    `type` TINYINT NOT NULL COMMENT '类型：1-电影 2-电视剧',
    `genre` VARCHAR(128) DEFAULT NULL COMMENT '类型（动作、科幻等，逗号分隔）',
    `release_year` INT DEFAULT NULL COMMENT '上映年份',
    `director` VARCHAR(128) DEFAULT NULL COMMENT '导演',
    `actors` VARCHAR(512) DEFAULT NULL COMMENT '演员（逗号分隔）',
    `description` TEXT DEFAULT NULL COMMENT '简介',
    `poster_url` VARCHAR(512) DEFAULT NULL COMMENT '海报URL',
    `rating` DECIMAL(3,1) DEFAULT NULL COMMENT '评分（0-10）',
    `duration` INT DEFAULT NULL COMMENT '时长（分钟）',
    `creator` VARCHAR(64) DEFAULT '' COMMENT '创建者',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updater` VARCHAR(64) DEFAULT '' COMMENT '更新者',
    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `deleted` TINYINT NOT NULL DEFAULT 0 COMMENT '是否删除：0-否 1-是',
    KEY `idx_type` (`type`),
    KEY `idx_release_year` (`release_year`),
    KEY `idx_tmdb_id` (`tmdb_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='影视表';
```

---

## 二、设计说明

### 2.1 为什么需要 tmdb_id？

1. **支持TMDB API集成**：
   - 用户可以通过TMDB搜索影视
   - 通过 `tmdb_id` 关联TMDB数据，自动填充影视信息
   - 避免重复创建相同的影视（相同 `tmdb_id` 可以复用）

2. **数据来源标识**：
   - `tmdb_id` 不为空：从TMDB创建
   - `tmdb_id` 为空：手动创建

3. **数据同步**：
   - 未来可以基于 `tmdb_id` 同步TMDB的最新数据（如评分更新）

### 2.2 唯一性约束

**当前设计**：
- 不设置 `tmdb_id` 的唯一约束
- 允许多个用户创建相同的影视（通过相同的 `tmdb_id`）
- 通过 `movie_record` 表的 `uk_user_movie` 约束保证用户不会重复添加同一影视

**可选方案**：
- 如果需要全局唯一（所有用户共享同一个影视），可以考虑：
  - 添加唯一索引：`UNIQUE KEY uk_tmdb_id (tmdb_id)`
  - 创建影视时先检查是否存在，存在则复用
  - 这样设计可以减少数据冗余，但需要更复杂的业务逻辑

**建议**：
- MVP阶段：不设置唯一约束，每个用户独立创建影视
- 后续优化：可以考虑全局共享影视，通过 `tmdb_id` 去重

---

## 三、索引设计

### 3.1 现有索引

**movie 表**：
- `PRIMARY KEY (id)`：主键索引
- `idx_type`：按类型查询
- `idx_release_year`：按年份查询
- `idx_tmdb_id`：按TMDB ID查询（新增）

**movie_record 表**：
- `PRIMARY KEY (id)`：主键索引
- `uk_user_movie (user_id, movie_id)`：唯一索引，保证用户不会重复添加
- `idx_user_id`：按用户查询
- `idx_movie_id`：按影视查询
- `idx_watch_status`：按状态查询
- `idx_watch_date`：按观看日期查询

### 3.2 查询场景分析

**常见查询场景**：
1. 查询用户的影视列表：`WHERE user_id = ? AND deleted = 0`
   - 使用索引：`idx_user_id`

2. 查询特定状态的记录：`WHERE user_id = ? AND watch_status = ?`
   - 使用索引：`idx_user_id` + `idx_watch_status`
   - 建议：可以添加组合索引 `idx_user_status (user_id, watch_status)`

3. 查询特定影视的记录：`WHERE movie_id = ?`
   - 使用索引：`idx_movie_id`

4. 通过TMDB ID查询影视：`WHERE tmdb_id = ?`
   - 使用索引：`idx_tmdb_id`（新增）

**优化建议**：
- 如果经常按 `user_id + watch_status` 组合查询，可以考虑添加组合索引
- 如果经常按 `user_id + watch_date` 排序，可以考虑添加组合索引

---

## 四、数据迁移（如果需要）

如果现有数据库已经有 `movie` 表，需要执行以下SQL：

```sql
-- 添加 tmdb_id 字段
ALTER TABLE `movie` 
ADD COLUMN `tmdb_id` BIGINT DEFAULT NULL COMMENT 'TMDB ID（用于关联TMDB数据）' AFTER `id`;

-- 添加索引
ALTER TABLE `movie` 
ADD INDEX `idx_tmdb_id` (`tmdb_id`);
```

**注意事项**：
- 如果表中有数据，添加字段不会影响现有数据
- `tmdb_id` 默认为 NULL，现有数据不受影响
- 索引创建可能需要一些时间（取决于数据量）

---

## 五、总结

### 5.1 关键点

1. **必须添加**：`tmdb_id` 字段和索引
2. **设计选择**：是否设置 `tmdb_id` 唯一约束（建议MVP阶段不设置）
3. **索引优化**：根据实际查询场景考虑添加组合索引

### 5.2 下一步

1. 执行SQL添加 `tmdb_id` 字段和索引
2. 在DO对象中添加 `tmdbId` 字段
3. 在业务逻辑中使用 `tmdb_id` 关联TMDB数据

---

**文档版本**: v1.0  
**最后更新**: 2025-12-19

